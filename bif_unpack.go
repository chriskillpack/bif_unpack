// Unpack BIF media index files as generated by Plex Media Server
//   Usage: bif_unpack input.bif [output_dir]
// output_dir is optional, if present image thumbnails will be extracted to output_dir
// BIF format 'reverse engineered' from https://github.com/anachirino/bifserver

package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io/ioutil"
	"os"
	"path"
)

var (
	headerMagic = []byte{0x89, 0x42, 0x49, 0x46, 0x0d, 0x0a, 0x1a, 0x0a, 0, 0, 0, 0}
)

type bifHeader struct {
	Magic    [12]byte
	Images   int32
	Interval int32
	_        [44]byte // padding
}

type bifEntry struct {
	Index  int32
	Offset int32
}

func main() {
	// Parse cmdline args
	args := os.Args[1:]
	if len(args) < 1 {
		fmt.Println("Missing input BIF file")
		os.Exit(1)
	}
	bifFilename := args[0]
	var outDir string
	if len(args) == 2 {
		outDir = args[1]
	}

	fc, err := ioutil.ReadFile(bifFilename)
	if err != nil {
		fmt.Printf("Could not read %s: %v\n", err)
		os.Exit(1)
	}

	br := bytes.NewReader(fc)
	header := bifHeader{}
	err = binary.Read(br, binary.LittleEndian, &header)
	if err != nil {
		fmt.Printf("Could not read from file: %v\n", err)
		os.Exit(1)
	}
	if bytes.Compare(header.Magic[:], headerMagic) != 0 {
		fmt.Println("Unexpected header")
		os.Exit(1)
	}
	fmt.Printf("Num images: %d\n", header.Images)
	fmt.Printf("Interval: %d\n", header.Interval)

	entries := make([]bifEntry, header.Images+1) // +1 for the additional tail entry
	if err = binary.Read(br, binary.LittleEndian, entries); err != nil {
		fmt.Printf("Err: %v\n", err)
		os.Exit(1)
	}
	// Check index of tail entry (0xFFFFFF, total offset)
	if entries[len(entries)-1].Index != -1 {
		fmt.Println("Unexpected final entry")
		os.Exit(1)
	}

	if outDir == "" {
		return
	}

	// Ensure output directory exists
	fi, err := os.Stat(outDir)
	if err != nil {
		if os.IsNotExist(err) {
			err = os.Mkdir(outDir, os.ModePerm)
			if err != nil {
				fmt.Printf("Error creating output directory %s: %v\n", outDir, err)
				os.Exit(1)
			}
		} else {
			fmt.Printf("Could not stat %s: %v\n", outDir, err)
			os.Exit(1)
		}
	} else {
		if !fi.IsDir() {
			fmt.Printf("Output %s is not a directory\n", outDir)
			os.Exit(1)
		}
	}

	for i := 0; i < len(entries)-1; i++ {
		entry := entries[i]

		fname := path.Join(outDir, fmt.Sprintf("%016d.jpg", entry.Index))
		f, err := os.Create(fname)
		if err != nil {
			fmt.Println("Could not create %s: %v\n", fname, err)
			break
		}
		defer f.Close()

		sz := entries[i+1].Offset - entry.Offset
		fmt.Printf("Writing %s, %d bytes\n", fname, sz)
		n, err := f.Write(fc[entry.Offset : entry.Offset+sz])
		if err != nil {
			fmt.Println("Failed to write file: %v\n", err)
			break
		}
		if n != int(sz) {
			fmt.Println("Failed to write %d bytes, only wrote %d\n", sz, n)
			break
		}
	}
}
